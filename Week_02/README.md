学习笔记
### 树
* 前序遍历: 根 -> 左 -> 右
* 中序遍历: 左 -> 根 -> 右
* 后序遍历: 左 -> 右 -> 根

#### 二叉树
* 它是一种特殊的树，二叉树的每个节点最多只能有两个叶子节点。

#### 二叉搜索树
1. 它是一种特殊的树，二叉树的每个节点最多只能有两个叶子节点
2. 它的节点比它左儿子的任意一个数都大，比它右儿子的任意一个结点都要小

#### 满二叉树
* 一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉数的层数为 k ，且节点总数为 (2^k) - 1, 则它就是满二叉树


### 堆
* Heap 可以快找到一堆数中的 `最大值` 或 `最小值`
* 二叉堆（大顶堆）特性
	* 是一个完全树
	* 树中任意节点的值总是 >= 其子节点的值

#### 完全二叉堆
* 若设二叉堆深度为 n，除第 n 层外，其他层 (1 ~ h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在左边，这就是完全二叉堆
* 二叉堆如果可以使用一个数组 a 表示的话，那么就满足一下特点
	* 根节点（顶堆元素）是 ：a[0]
	* 索引为 i 的左孩子的索引是 (2 * i + 1)
	* 索引为 i 的右孩子的索引是 (2 * i + 2)
	* 索引为 i 的父节点的索引是 floor((i-1)/2)

### 递归
* 递归三部曲
	 1. 找到递归终止条件：递归应该在什么时候结束？
	 2. 本级递归应改做什么：在这一级递归中，应该完成什么任务？
	 3. 找返回值：应该给下一级传递什么（下一次递归传递的什么参数）

* 思维要点
	1. 不要人肉就行递归
	2. 找到最近最简方法，将其拆解成可重复解决的问题（重复子问题） 
	3. 数学归纳法思维	

* 递归代码模板

``` java
public voide recursion(int level, int param) {
		// 终止条件
		if level > max {
			// 处理结果
			return
		}
		
		// 当前递归层处理的逻辑
		process(level, prarm)
		
		// 给下一层传递什么条件或参数
		recursion(level + 1, newParam)
	} 
```

